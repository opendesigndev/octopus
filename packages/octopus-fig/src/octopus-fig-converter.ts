import { setDefaults, setLogger } from './services'
import { DesignConverter } from './services/conversion/design-converter'
import { getPlatformFactories, setPlatformFactories } from './services/general/platforms'
import { readPackageMeta } from './utils/read-pkg-meta'

import type { DesignConversionResult } from './services/conversion/design-converter'
import type { AbstractExporter } from './services/exporters/abstract-exporter'
import type { ImageSize } from './services/general/image-size/image-size'
import type { NodeFactories, WebFactories } from './services/general/platforms'
import type { Logger } from './typings'
import type { PackageMeta } from './utils/read-pkg-meta'
// eslint-disable-next-line import/no-named-as-default
import type EventEmitter from 'eventemitter3'

export type OctopusConverterOptions = {
  platformFactories: WebFactories | NodeFactories
  /** Optional custom Logger. If not passed, default logger will be used. */
  logger?: Logger
  loggerEnabled?: boolean
}

export type DesignConverterOptions = {
  /** `EventEmitter` providing source data to the converter */
  designEmitter: EventEmitter | null
  /** Optional unique Design Identifier. If not passed, will be generated by UUIDv4. */
  designId?: string
  /** Optional Exporter. */
  exporter?: AbstractExporter
  /** OctopusManifest updating Interval (in milliseconds) */
  partialUpdateInterval?: number
  /**
   * When set to `true`, instead of `DesignConversionResult` will return `null`.
   * Useful when you don't care what is returned and just need the design assets to be exported.
   */
  skipReturn?: boolean
}

/**
 * Octopus Figma Converter
 * Main class for converting Figma designs into Octopus3.
 *
 * There are three main processing steps:
 * - reading source data (using _reader_)
 * - conversion (using `.convertDesign()` method with `EventEmitter` instance produced by reader)
 * - exporting (using _exporter_)
 *
 * Readers used in other Octopus converters return `SourceDesign` instance, which, actually, is object with static values inside.
 * In case of Figma, we have slightly different approach because of it's asynchronous origin (requesting values using HTTP).
 * So, to provide source data as fast as possible to the converter we use `EventEmitter` inside of Figma Reader's `SourceDesign` instance.
 * This makes it possible to process data almost as fast as it's downloaded from Figma's API.
 */
export class OctopusFigConverter {
  private _pkg: PackageMeta
  private _services: {
    benchmark: {
      benchmarkAsync: <T>(cb: (...args: unknown[]) => Promise<T>) => Promise<{ result: T; time: number }>
    }
    imageSize: (buffer: ArrayBuffer) => Promise<ImageSize | undefined>
    buffer: {
      base64ToUint8Array: (base64: string) => Uint8Array
    }
  }

  constructor(options: OctopusConverterOptions) {
    this._setGlobals(options)
    this._pkg = readPackageMeta()
    this._services = this._initServices()
  }

  get benchmarkAsync() {
    return this._services.benchmark.benchmarkAsync
  }

  get imageSize() {
    return this._services.imageSize
  }

  get base64ToUint8Array() {
    return this._services.buffer.base64ToUint8Array
  }

  private _initServices() {
    return {
      benchmark: getPlatformFactories().createBenchmarkService(),
      imageSize: getPlatformFactories().createImageSizeService(),
      buffer: getPlatformFactories().createBufferService(),
    }
  }

  private _setGlobals(options: OctopusConverterOptions): void {
    setPlatformFactories(options.platformFactories)
    setDefaults({
      logger: { enabled: options.loggerEnabled ?? true },
    })
    if (options.logger) setLogger(options.logger)
  }

  get pkg(): PackageMeta {
    return this._pkg
  }

  async convertDesign(options: DesignConverterOptions): Promise<DesignConversionResult | null> {
    return new DesignConverter(options, this).convert()
  }
}
