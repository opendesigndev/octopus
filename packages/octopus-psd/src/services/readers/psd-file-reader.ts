import { readFile } from 'fs/promises'
import path from 'path'

import { getRenderer } from '@opendesign/image-icc-profile-converter'
import { asNumber } from '@opendesign/octopus-common/dist/utils/as.js'
import { benchmarkAsync } from '@opendesign/octopus-common/dist/utils/benchmark-node.js'
import { displayPerf } from '@opendesign/octopus-common/dist/utils/console.js'
import Psd, { AliKey } from '@webtoon/psd-ts'
import chalk from 'chalk'
import Jimp from 'jimp'
import rimraf from 'rimraf'
import { v4 as uuidv4 } from 'uuid'

import { SourceDesign } from '../../entities/source/source-design.js'
import { getRawData } from '../../utils/raw.js'
import { logger } from '../instances/logger.js'

import type { SourceImage } from '../../entities/source/source-design.js'
import type { Renderer } from '@opendesign/image-icc-profile-converter'
import type { NodeChild, Layer, Group } from '@webtoon/psd-ts'

type ConvertImageOptions = {
  buff: Uint8ClampedArray | Uint8Array
  width: number
  height: number
  name: string
  iccProfile: Uint8Array | undefined
}

type ProcessedImage = {
  name: string
  promiseBuffer: Promise<Buffer>
  width: number
  height: number
}

export type PSDFileReaderOptions = WithRendererOptions & {
  /** wasm image processing tool */
  renderer?: Renderer
}

export type WithRendererOptions = {
  /** Path to the .psd design file. */
  path: string

  /** Unique ID. If not passed, will be generated by UUIDv4 */
  designId?: string
}

/**
 * Reader that converts Adobe Photoshop .psd file into `SourceDesign` object.
 */
export class PSDFileReader {
  private _path: string
  private _designId: string
  private _sourceDesign: Promise<SourceDesign | null>
  private _images: ProcessedImage[] = []
  private _renderer?: Renderer

  static OUTPUT_DIR = 'workdir'
  static RENDER_IMG = 'preview.png'
  static SOURCE_FILE = 'source.json'
  static SHAPE_LAYER_KEYS = [
    AliKey.VectorStrokeData,
    AliKey.VectorStrokeContentData,
    AliKey.SolidColorSheetSetting,
    AliKey.GradientFillSetting,
    AliKey.PatternFillSetting,
  ]
  static ADJUSTMENT_LAYER_KEYS = [
    AliKey.SolidColorSheetSetting,
    AliKey.GradientFillSetting,
    AliKey.PatternFillSetting,
    AliKey.PatternFillSetting,
    AliKey.BrightnessAndContrast,
    AliKey.Levels,
    AliKey.Curves,
    AliKey.Exposure,
    AliKey.Vibrance,
    AliKey.HueSaturationOld,
    AliKey.HueSaturation,
    AliKey.ColorBalance,
    AliKey.BlackAndWhite,
    AliKey.PhotoFilter,
    AliKey.ChannelMixer,
    AliKey.ColorLookup,
    AliKey.Invert,
    AliKey.Posterize,
    AliKey.Threshold,
    AliKey.GradientMapSettings,
    AliKey.SelectiveColor,
  ]

  static async withRenderer(options: WithRendererOptions): Promise<PSDFileReader> {
    const renderer = await getRenderer()

    return new PSDFileReader({ ...options, renderer })
  }

  /**
   * Converts given PSD file into SourceDesign.
   * @constructor
   * @param {PSDFileReaderOptions} options
   */
  constructor(options: PSDFileReaderOptions) {
    this._path = options.path
    this._renderer = options.renderer
    this._designId = options.designId || uuidv4()
    this._sourceDesign = this._initSourceDesign()
  }

  /**
   * Path to the PSD file.
   */
  get path(): string {
    return this._path
  }

  /**
   * Unique Design Identifier.
   * Passed in constructor, otherwise generated by UUIDv4.
   */
  get designId(): string {
    return this._designId
  }

  /**
   * Returns `SourceDesign` instance built from given design path using `@avocode/psd-parser`. It encapsulates all the design assets required by converter as input.
   * @returns {SourceDesign | null} Returns `SourceDesign` instance or `null` if parsing was not successful.
   */
  get sourceDesign(): Promise<SourceDesign | null> {
    return this._sourceDesign
  }

  /**
   * Cleans TempDir where source.json and source images were saved.
   */
  async cleanup(): Promise<void> {
    return new Promise((resolve, reject) => {
      rimraf(this._outDir, (error: Error | null | undefined) => {
        error ? reject(error) : resolve()
      })
    })
  }

  private get _outDir() {
    return path.join(PSDFileReader.OUTPUT_DIR, this.designId)
  }

  private async _convertImage({ width, height, buff, name, iccProfile }: ConvertImageOptions): Promise<void> {
    const processedBuff = this._renderer ? await this._renderer.render(buff, iccProfile) : buff

    const image = new Jimp(width, height)
    const scanned = image.scan(0, 0, image.bitmap.width, image.bitmap.height, function (_x, _y, index) {
      this.bitmap.data[index + 0] = processedBuff[index + 0]
      this.bitmap.data[index + 1] = processedBuff[index + 1]
      this.bitmap.data[index + 2] = processedBuff[index + 2]
      this.bitmap.data[index + 3] = processedBuff[index + 3]
    })

    const parsed = new Jimp(scanned)
    this._images.push({ width, height, name, promiseBuffer: parsed.getBufferAsync(Jimp.MIME_PNG) })
    return
  }

  private async _convertMaskImage(layer: Layer | Group, iccProfile: Uint8Array | undefined): Promise<void> {
    if (!layer.userMask || !layer.realUserMask) {
      return
    }

    const realUserMask = await layer.realUserMask()
    const buff = realUserMask ?? (await layer.userMask())

    if (!buff) {
      return
    }

    const maskData = realUserMask ? layer?.maskData?.realData : layer.maskData

    if (maskData?.flags.layerMaskDisabled === true || maskData?.flags.userMaskFromRenderingOtherData) {
      return
    }

    const width = asNumber(maskData?.right, 0) - asNumber(maskData?.left, 0)
    const height = asNumber(maskData?.bottom, 0) - asNumber(maskData?.top, 0)

    const name = `${String(layer.additionalProperties?.[AliKey.LayerId]?.value)}_user_mask.png`

    await this._convertImage({ width, height, buff, name, iccProfile })
  }

  private async _convertImages(layer: NodeChild, iccProfile: Uint8Array | undefined): Promise<void> {
    if (layer.type === 'Group') {
      await this._convertMaskImage(layer, iccProfile)

      for (const child of layer.children) {
        await this._convertImages(child, iccProfile)
      }
      return
    }

    const id = layer.additionalProperties?.[AliKey.LayerId]?.value ?? 'undefined'
    const { width, height } = layer

    if (width === 1 && height === 1) {
      return
    }
    const name = `${id}.png`

    let buff

    try {
      buff = await layer.composite()
    } catch (e) {
      logger.error(`could not export image: ${name}`)
      return
    }

    await this._convertImage({ width, height, buff, name, iccProfile })
    await this._convertMaskImage(layer, iccProfile)
  }

  private async _convertPatterns(psd: Psd, iccProfile: Uint8Array | undefined): Promise<void> {
    const patterns = psd.patterns
    await Promise.all(
      patterns.map(async (pattern) => {
        const width = pattern.patternData.rectangle.right - pattern.patternData.rectangle.left
        const height = pattern.patternData.rectangle.bottom - pattern.patternData.rectangle.top
        const name = `${pattern.id}.png`
        const buff = await psd.decodePattern(pattern)
        await this._convertImage({ width, height, buff, name, iccProfile })
      })
    )
  }

  private async _convertAssets(psd: Psd): Promise<void> {
    const iccProfile = psd.icc_profile
    await Promise.all(psd.children.map((child) => this._convertImages(child, iccProfile)))
    await this._convertPatterns(psd, iccProfile)
  }

  private async _getPsd(): Promise<Psd> {
    const psd = Psd.parse((await readFile(this.path)).buffer)

    if (psd.children.length > 0) {
      await this._convertAssets(psd)
      return psd
    }

    const child = {
      width: psd.width,
      height: psd.height,
      opacity: psd.opacity,
      additionalProperties: {
        lnsr: {
          _isUnknown: true,
          signature: '8B64',
          key: 'lnsr',
          data: Buffer.from('bgnd', 'utf8'),
        },
        lyid: {
          key: 'lyid',
          value: 1,
        },
      },
      composite: psd.composite.bind(psd),
    }

    const psdCopy = Object.create(psd, {
      children: {
        value: [],
      },
    })

    psdCopy.children.push(child as unknown as Layer)

    await this._convertAssets(psdCopy)

    return psdCopy
  }

  private async _getSourceComponent(): Promise<{ raw: Psd | null }> {
    const { time, result } = await benchmarkAsync(() => this._getPsd())

    logger.info(`Assets saved in directory: ${chalk.yellow(this.designId)} ${displayPerf(time)}`)

    return { raw: result }
  }

  private async _getImages(): Promise<SourceImage[]> {
    const images = await Promise.all(
      this._images.map(async ({ promiseBuffer, ...rest }) => {
        const buffer = await promiseBuffer

        return {
          ...rest,
          data: buffer,
        }
      })
    )

    return images
  }

  private async _initSourceDesign(): Promise<SourceDesign | null> {
    const designId = this.designId
    const { raw } = await this._getSourceComponent()

    if (!raw) return null

    const parsedPsd = getRawData(raw)
    const images = await this._getImages()
    const sourceDesign = new SourceDesign({ designId, component: parsedPsd, images })
    return sourceDesign
  }
}
