import { asNumber } from '@opendesign/octopus-common/dist/utils/as.js'
import { uniqueIdFactory } from '@opendesign/octopus-common/dist/utils/common.js'
import Psd, { AliKey } from '@webtoon/psd-ts'
import { v4 as uuidv4 } from 'uuid'

import { SourceDesign } from '../../entities/source/source-design.js'
import PROPS from '../../utils/prop-names.js'
import { getRawData } from '../../utils/raw.js'

import type { PsdSourceImage } from '../../entities/source/source-design.js'
import type { Renderer } from '@opendesign/image-icc-profile-converter'
import type { DesignMeta } from '@opendesign/octopus-common/dist/typings/octopus-common/index.js'
import type { NodeChild, Layer, Group } from '@webtoon/psd-ts'

export type ConvertImageOptions = {
  buff: Uint8ClampedArray | Uint8Array
  width: number
  height: number
  id: string
  iccProfile: Uint8Array | undefined
}

type ProcessedImage = {
  id: string
  promisedData: Promise<Uint8Array>
  width: number
  height: number
}

export type PSDFileReaderOptions = {
  /** Path to the .psd design file. */
  path?: string

  /** wasm image processing tool */
  renderer?: Renderer
}

/**
 * Reader that converts Adobe Photoshop .psd file into `SourceDesign` object.
 */
export abstract class PSDFileReaderCommon {
  private _designId: string
  protected _images: ProcessedImage[] = []
  protected _renderer?: Renderer
  private _uniqueId: () => string
  private _psd: Psd

  static _renderer: Renderer
  static SHAPE_LAYER_KEYS = [
    AliKey.VectorStrokeData,
    AliKey.VectorStrokeContentData,
    AliKey.SolidColorSheetSetting,
    AliKey.GradientFillSetting,
    AliKey.PatternFillSetting,
  ]
  static ADJUSTMENT_LAYER_KEYS = [
    AliKey.SolidColorSheetSetting,
    AliKey.GradientFillSetting,
    AliKey.PatternFillSetting,
    AliKey.PatternFillSetting,
    AliKey.BrightnessAndContrast,
    AliKey.Levels,
    AliKey.Curves,
    AliKey.Exposure,
    AliKey.Vibrance,
    AliKey.HueSaturationOld,
    AliKey.HueSaturation,
    AliKey.ColorBalance,
    AliKey.BlackAndWhite,
    AliKey.PhotoFilter,
    AliKey.ChannelMixer,
    AliKey.ColorLookup,
    AliKey.Invert,
    AliKey.Posterize,
    AliKey.Threshold,
    AliKey.GradientMapSettings,
    AliKey.SelectiveColor,
  ]

  /**
   * Converts given PSD file into SourceDesign.
   * @constructor
   * @param {PSDFileReaderOptions} options
   */
  constructor(options: PSDFileReaderOptions) {
    this._uniqueId = uniqueIdFactory(1000000)
    this._renderer = options.renderer
    this._designId = uuidv4()
  }

  /**
   * Unique Design Identifier.
   * Passed in constructor, otherwise generated by UUIDv4.
   */
  get designId(): string {
    return this._designId
  }

  protected abstract _convertImage({ width, height, buff, id, iccProfile }: ConvertImageOptions): Promise<void>

  private async _convertMaskImage(layer: Layer | Group, iccProfile: Uint8Array | undefined): Promise<void> {
    if (!layer.userMask || !layer.realUserMask) {
      return
    }

    const realUserMask = await layer.realUserMask()
    const buff = realUserMask ?? (await layer.userMask())

    if (!buff) {
      return
    }

    const maskData = realUserMask ? layer?.maskData?.realData : layer.maskData

    if (maskData?.flags.layerMaskDisabled === true || maskData?.flags.userMaskFromRenderingOtherData) {
      return
    }

    const width = asNumber(maskData?.right, 0) - asNumber(maskData?.left, 0)
    const height = asNumber(maskData?.bottom, 0) - asNumber(maskData?.top, 0)

    const id = `${String(layer.additionalProperties?.[AliKey.LayerId]?.value)}_user_mask.png`

    await this._convertImage({ width, height, buff, id, iccProfile })
  }

  private async _convertImages(layer: NodeChild, iccProfile: Uint8Array | undefined): Promise<void> {
    if (layer.type === 'Group') {
      await this._convertMaskImage(layer, iccProfile)

      for (const child of layer.children) {
        await this._convertImages(child, iccProfile)
      }
      return
    }

    const { additionalProperties } = layer

    if (typeof additionalProperties === 'undefined') {
      throw new Error('Layer is missing additional properties')
    }

    const id = `${additionalProperties[AliKey.LayerId]?.value}.png`

    const { width, height } = layer

    if (width === 1 && height === 1) {
      return
    }

    let buff

    try {
      buff = await layer.composite()
    } catch (e) {
      console?.error(`could not export image: ${id}`)
      console.error(e)
      return
    }

    await this._convertImage({ width, height, buff, id, iccProfile })
    await this._convertMaskImage(layer, iccProfile)
  }

  private async _convertPatterns(psd: Psd, iccProfile: Uint8Array | undefined): Promise<void> {
    const patterns = psd.patterns
    await Promise.all(
      patterns.map(async (pattern) => {
        const width = pattern.patternData.rectangle.right - pattern.patternData.rectangle.left
        const height = pattern.patternData.rectangle.bottom - pattern.patternData.rectangle.top
        const id = `${pattern.id}.png`
        const buff = await psd.decodePattern(pattern)
        await this._convertImage({ width, height, buff, id, iccProfile })
      })
    )
  }

  private async _convertAssets(psd: Psd, componentIds?: number[]): Promise<void> {
    const iccProfile = psd.icc_profile
    await Promise.all(
      psd.children
        .filter((child) => {
          if (!componentIds) {
            return true
          }

          const lyid = child.additionalProperties?.lyid?.value

          return lyid ? componentIds.includes(lyid) : false
        })
        .map((child) => this._convertImages(child, iccProfile))
    )
    await this._convertPatterns(psd, iccProfile)
  }

  private _assignMissingLayerId(child: NodeChild): void {
    const { additionalProperties } = child
    if (!additionalProperties) {
      throw new Error('Layer is missing additional properties')
    }

    if (!additionalProperties.lyid) {
      additionalProperties.lyid = {
        value: Number(this._uniqueId()),
        key: AliKey.LayerId,
        signature: '8B64',
      }
    }

    if (child.children) {
      child.children.forEach((child) => {
        this._assignMissingLayerId(child)
      })
    }
  }

  private _assignMissingLayerIds(psd: Psd): void {
    psd.children.forEach((child) => {
      this._assignMissingLayerId(child)
    })
  }

  protected abstract _getBuffer(): Promise<Uint8Array>

  private async _getPsd(): Promise<Psd> {
    if (this._psd) {
      return this._psd
    }

    const data = await this._getBuffer()

    const psd = Psd.parse(data.buffer)
    this._assignMissingLayerIds(psd)

    if (psd.children.length > 0) {
      return psd
    }

    const child = {
      width: psd.width,
      height: psd.height,
      opacity: psd.opacity,
      additionalProperties: {
        lnsr: {
          _isUnknown: true,
          signature: '8B64',
          key: 'lnsr',
          // 'bgnd' in utf-8
          data: new Uint8Array([0x62, 0x67, 0x6e, 0x64]),
        },
        [PROPS.LAYER_ID]: {
          key: PROPS.LAYER_ID,
          value: 1,
        },
      },
      composite: psd.composite.bind(psd),
    }

    const psdCopy = Object.create(psd, {
      children: {
        value: [],
      },
    })

    psdCopy.children.push(child as unknown as Layer)

    this._psd = psdCopy

    return psdCopy
  }

  private async _getImages(): Promise<PsdSourceImage[]> {
    const images = await Promise.all(
      this._images.map(async ({ promisedData, ...rest }) => {
        return {
          ...rest,
          getImageData: async () => await promisedData,
        }
      })
    )

    return images
  }

  /**
   * Returns `DesignMeta` with list of Artboards and designName
   */
  async getDesignMeta(): Promise<DesignMeta> {
    const psd = await this._getPsd()
    psd.name
    return {
      name: psd.name,
      origin: {
        name: 'PHOTOSHOP',
        version: '0',
      },
      pages: [],
      components: psd.children.map((artboard) => {
        return {
          name: artboard.name,
          id: String(artboard.additionalProperties?.lyid?.value),
          role: 'ARTBOARD' as const,
        }
      }),
    }
  }

  /**
   * Returns `SourceDesign` instance built from given design path using `@avocode/psd-parser`. It encapsulates all the design assets required by converter as input.
   * @returns {SourceDesign | null} Returns `SourceDesign` instance or `null` if parsing was not successful.
   */
  async getSourceDesign({ ids }: { ids?: number[] } = {}): Promise<SourceDesign | null> {
    const componentIds = ids?.map((id) => Number(id))
    const designId = this.designId
    const psd = await this._getPsd()

    if (!psd) return null

    await this._convertAssets(psd, componentIds)
    const parsedPsd = getRawData(psd)
    const images = await this._getImages()
    const sourceDesign = new SourceDesign({ designId, component: parsedPsd, images, componentIds })

    return sourceDesign
  }
}
